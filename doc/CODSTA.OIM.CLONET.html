<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
Ensure 'clone()' method of non-final Cloneable class declared to throw 'CloneNotSupportedException' [CODSTA.OIM.CLONET]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
Ensure 'clone()' method of non-final Cloneable class declared to throw 'CloneNotSupportedException' [CODSTA.OIM.CLONET]
</STRONG>
<p>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This rule identifies any 'clone()' method in a 
non-"final" Cloneable class that does does not throw  
'CloneNotSupportedException'.  An error is reported for
each occurrence.


</PRE>
<STRONG>
SCOPE LEVEL
</STRONG>
<PRE>

METHOD


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v6.0


</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

"final" classes implementing 'Cloneable' should not be declared to
throw 'CloneNotSupportedException' because their implementation of 'clone ()'
should be a fully functional method that will not throw the exception.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

'clone()' method should be declared to throw 
'CloneNotSupportedException' if the declaring class is non
"final". If not, any class that extends that declaring class
would not be able to opt out of clonability by providing the
following clone method:

public final Object clone() throws CloneNotSupportedException {
    throw new CloneNotSupportedException();
}


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

package examples.rules.codsta.oim;

public class CLONEFixed implements Cloneable {
    private Entry[] buckets = null;
 
    private static class Entry {
        Object key;
        Object value;
        Entry next;

        Entry (Object key, Object value, Entry next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
      
        Entry deepCopy () {
            Entry n = next == null ? null : next.deepCopy ();
            return new Entry (key, value, n);
        }

    }
    
    public Object clone () {  // VIOLATION: does not throw 'CloneNotSupportedException'
        CLONEFixed result = (CLONEFixed)super.clone();
        result.buckets = new Entry[buckets.length];
        for (int i = 0; i &lt; buckets.length; i++) {
            if (buckets[i] != null) {
                result.buckets[i] = (Entry)buckets[i].deepCopy();
            }
        }
        return result;
    }
}


</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

package examples.rules.codsta.oim;

public class CLONEFixed implements Cloneable {
    private Entry[] buckets = null;
 
    private static class Entry {
        Object key;
        Object value;
        Entry next;

        Entry (Object key, Object value, Entry next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
      
        Entry deepCopy () {
            Entry n = next == null ? null : next.deepCopy ();
            return new Entry (key, value, n);
        }

    }
    
    public Object clone () throws CloneNotSupportedException {  // FIXED
        CLONEFixed result = (CLONEFixed)super.clone();
        result.buckets = new Entry[buckets.length];
        for (int i = 0; i &lt; buckets.length; i++) {
            if (buckets[i] != null) {
                result.buckets[i] = (Entry)buckets[i].deepCopy();
            }
        }
        return result;
    }
}


</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

Joshua Bloch : "Effective Java - Programming Language Guide"
Addison Wesley, 2001, pp. 45-52

</PRE>
</BODY>
</HTML>
