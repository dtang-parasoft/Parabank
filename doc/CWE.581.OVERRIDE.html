<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
Override 'Object.hashCode()' when you override 'Object.equals()' and vice versa [CWE.581.OVERRIDE]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
Override 'Object.hashCode()' when you override 'Object.equals()' and vice versa [CWE.581.OVERRIDE]
</STRONG>
<p>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This rule identifies code that meets one of the following conditions:

1.  The code does not override 'Object.hashCode()' when it overrides 'Object.
equals()'.

2.  The code does not override 'Object.equals()' when it overrides 'Object.
hashCode()'.

By default, errors will be reported in both cases.  An error is reported for
each occurrence.



</PRE>
<STRONG>
SCOPE LEVEL
</STRONG>
<PRE>
CLASS



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v4.5



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

There are two Quick Fix options available for this rule.  They are:

1.  Create a stub for the 'hashCode()' or 'equals()' method: This quickfix
option will create a 'hashCode()' or 'equals()' method stub which just throws an
"UnsupportedOperationException".  The user should then replace the line that
throws the exception with a correct implementation of 'hashCode()'.

2.  Generate a 'hashCode()' method using Joshua Bloch's algorithm (This Quick Fix
option only applies to cases where the 'equals()' method is overridden without
overriding the 'hashCode()' method.  There is currently no second Quick Fix
option for cases where the 'hashCode()' method is overridden without overriding
the 'equals()' method.): This Quick Fix option will generate a 'hashCode()'
implementation using the algorithm described below in the section "JOSHUA
BLOCH'S ALGORITHM FOR DEFINING A GOOD HASHCODE METHOD".  If the 'equals()'
method for the class does not use any of the class' fields in its
implementation, the generated 'hashCode()' method will be a stub that just
returns 0.

Note that the generated implementation of 'hashCode()' is not guaranteed to be
correct.  For instance, for fields of Object types, the generated 'hashCode()'
method will just invoke the 'hashCode()' method of the field to determine its
hash code.  This is correct if the 'equals()' method just calls 'equals()' on
the field for the equality comparison but incorrect if a more complex equality
comparison is used.  You should inspect the generated method and modify it as
necessary.

Also, this second Quick Fix option is not available for all cases.  In
particular, it is not available for any class which has a field which is a
multidimensional array.



</PRE>
<STRONG>
SECURITY RELEVANCE
</STRONG>
<PRE>

"Java objects are expected to obey a number of invariants related to equality.
One of these invariants is that equal objects must have equal hashcodes. . . If
this invariant is not upheld, it is likely to cause trouble if objects of this
class are stored in a collection. If the objects of the class in question are
used as a key in a Hashtable or if they are inserted into a Map or Set, it is
critical that equal objects have equal hashcodes." [CWE-581]



</PRE>
<STRONG>
PARAMETERS
</STRONG>
<PRE>

-Check that 'hashCode()' is overridden whenever 'equals()' is overridden
    -Default value is "true".
-Check that 'equals()' is overridden whenever 'hashCode()' is overridden
    -Default value is "true".
-Include methods inherited from "abstract" superclasses in the checking.
    -Default value is "false".
    -If this parameter is enabled, the rule will flag a violation if code
     inherits an overridden version of 'equals()' from an abstract superclass
     but inherits the implementation of 'hashCode()' directly from "java.lang.
     Object" (if "Check that 'hashCode()' is overridden whenever 'equals()' is
     overridden" is enabled).
    -Similarly, if this parameter is enabled, the rule will flag a violation if
     code inherits an overridden version of 'hashCode()' from an abstract
     superclass but inherits the implementation of 'equals()' directly from
     "java.lang.Object" (if "Check that 'equals()' is overridden whenever
     'hashCode()' is overridden" is enabled).



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

The general contract for the 'hashCode()' method states, "If two objects are
equal according to the equals(Object) method, then calling the hashCode method
on each of the two objects must produce the same integer result".  This means
that, if you override the 'equals()' method to provide an implementation other
than the default implementation, you must also override 'hashCode()' so that two
objects which are equal according to the 'equals(Object)' method will still
produce the same integer result when the 'hashCode()' method is called.

Although it is not required by contract, if you override the 'hashCode()'
method, it is recommended to also override the 'equals()' method.  Trying to
ensure that two objects which have the same hash code must always be equal (to
the extent that this is possible) will improve the performance of data
structures which use hash codes and is generally the expected behavior (even
though this behavior is not technically required).

In summary, the 'equals()' and 'hashCode()' method should always be overridden
together.  Overriding one without the other is likely to lead to problems.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

package examples.rules.codsta.oim;

public class OVERRIDE {  // VIOLATION: no hashCode() defined
    private int value;

    public boolean equals(Object obj) {
        if (obj instanceof OVERRIDE) {
            OVERRIDE temp = (OVERRIDE)obj;
            return temp.value == value;
        }
        else {
            return false;
        }
    }
}

class OVERRIDE2 {  // VIOLATION: no equals() defined
    private int value;

    public int hashCode() {
        return value;
    }
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

Override both the 'hashCode()' and the 'equals()' method in both classes.  The
'hashCode()' method should return a number based on the same fields that the
'equals()' method uses to test for equality.  Ideally 'hashCode()' should
produce the same value for two objects only when 'equals()' return true when
called on them.

Try to define the 'equals()' method for the class "OVERRIDE2" so that two
objects with the same hash code will always be equal.

package examples.rules.codsta.oim;

public class OVERRIDEFixed {  // FIXED: now overrides 'hashCode()'
    private int value;

    public boolean equals(Object obj) {
        if (obj instanceof OVERRIDEFixed) {
            OVERRIDEFixed temp = (OVERRIDEFixed)obj;
            return temp.value == value;
        }
        else {
            return false;
        }
    }

    public int hashCode() {
        int result= 17;
        result= 37*result + value;
        return result;
    }
}

class OVERRIDE2Fixed {  // FIXED: now overrides equals()
    private int value;

    public boolean equals(Object obj) {
        if (obj instanceof OVERRIDE2Fixed) {
            return ((OVERRIDE2Fixed)temp).value == value;
        }
        else {
            return false;
        }
    }

    public int hashCode() {
        return value;
    }
}

JOSHUA BLOCH'S ALGORITHM FOR DEFINING A GOOD HASHCODE METHOD

Expert Joshua Bloch, in his book "Effective Java - Programming Language Guide",
recommends using the following algorithm to generate a good "hashCode()" method:

1. Store a constant nonzero value (such as 17) in an int variable called "result".
2. For each field of the object taken into account by the "equals()" method,
    a. Calculate the hash code "c" of that field as follows:
        i.    If the field is a boolean, compute (f ? 0 : 1).
        ii.   If the field is a byte, char, short, or int, compute (int)f.
        iii.  If the field is a long, compute (int)(f ^ (f &gt;&gt;&gt; 32)).
        iv.   If the field is a float, compute Float.floatToIntBits (f).
        v.    If the field is a double, compute Double.doubleToLongBits(f), and
              then hash the resulting long as in step iii.
        vi.   If the field is an object reference and your class's "equals()" method
              compares this field by recursively invoking "equals()", recursively
              invoke "hashCode()" on the field.  If a more complex comparison is
              used, compute a "canonical representation" of the field and invoke
              "hashCode()" on this representation.
        viii. If the field is an array, treat it as if each element were a separate
              field.  That is, compute the hash code for each significant element
              as described in steps i-viii, and combine them using the rule in step
              b.
    b. Combine the hash code "c" into the value of "result" using the following
       formula:

       result = 37*result + c;

3. Return "result".

A simple example of Joshua Bloch's algorithm is shown in the "REPAIR" section.



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

This page <A HREF="http://kind.ucd.ie/documents/whitepapers/code_standards/java.html">http://kind.ucd.ie/documents/whitepapers/code_standards/java.html</A> hosts
the Caltech Infospheres Java Coding Recommendations archived here: 
<A HREF="http://www.sourceformat.com/coding-standard-java-caltech.htm">http://www.sourceformat.com/coding-standard-java-caltech.htm</A>

Joshua Bloch: "Effective Java - Programming Language Guide".
Addison-Wesley, 2001, pp. 36 -41

CWE-581: Object Model Violation: Just One of Equals and Hashcode Defined
<A HREF="https://cwe.mitre.org/data/definitions/581.html">https://cwe.mitre.org/data/definitions/581.html</A>

SEI CERT Oracle Coding Standard for Java
MET09-J. Classes that define an equals() method must also define a hashCode() method
<A HREF="https://wiki.sei.cmu.edu/confluence/display/java/MET09-J.+Classes+that+define+an+equals%28%29+method+must+also+define+a+hashCode%28%29+method">https://wiki.sei.cmu.edu/confluence/display/java/MET09-J.+Classes+that+define+an+equals%28%29+method+must+also+define+a+hashCode%28%29+method</A>


</PRE>
<STRONG>
LOG
</STRONG>
<PRE>

@severity-from 4(v8.0)

</PRE>
</BODY>
</HTML>
